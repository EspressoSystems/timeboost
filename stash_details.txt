diff --git a/sailfish/src/consensus.rs b/sailfish/src/consensus.rs
index d93fc83..9d99fc4 100644
--- a/sailfish/src/consensus.rs
+++ b/sailfish/src/consensus.rs
@@ -1,4 +1,4 @@
-use std::collections::{BTreeMap, BTreeSet, HashSet};
+use std::collections::{BTreeMap, HashSet};
 use std::num::NonZeroUsize;
 use std::sync::Arc;
 
@@ -22,8 +22,6 @@ mod dag;
 mod ord;
 mod vote;
 
-use ord::OrderedVertex;
-
 pub use dag::Dag;
 pub use vote::VoteAccumulator;
 
@@ -44,7 +42,7 @@ pub struct Consensus {
     committee: StaticCommittee,
 
     /// The set of vertices that we've received so far.
-    buffer: BTreeSet<OrderedVertex>,
+    buffer: Dag,
 
     /// The set of values we have delivered so far.
     delivered: HashSet<(RoundNumber, PublicKey)>,
@@ -75,12 +73,6 @@ pub struct Consensus {
 
     /// The DAG of vertices.
     dag: Dag,
-
-    /// The DAG we populate for when we are in catchup
-    candidate_dag: Dag,
-
-    /// State for when we fall behind
-    catchup: bool,
 }
 
 impl Consensus {
@@ -93,8 +85,7 @@ impl Consensus {
             label: Label::new(keypair.public_key()),
             keypair,
             dag: Dag::new(committee.size()),
-            candidate_dag: Dag::new(committee.size()),
-            buffer: BTreeSet::new(),
+            buffer: Dag::new(committee.size()),
             delivered: HashSet::new(),
             timeouts: BTreeMap::new(),
             no_votes: VoteAccumulator::new(committee.clone()),
@@ -105,7 +96,6 @@ impl Consensus {
             round: RoundNumber::genesis(),
             committed_round: RoundNumber::genesis(),
             transactions: TransactionsQueue::new(),
-            catchup: false,
         }
     }
 
@@ -233,19 +223,7 @@ impl Consensus {
 
         match self.try_to_add_to_dag(&v) {
             Err(()) => {
-                if v.round() - self.round() > 2.into() {
-                    self.catchup = true;
-                    self.buffer.clear();
-                    // Do we have anything in our state for previous round?
-                    // We are in catchup, so optimistically add to the candidate dag
-                    // Essentially treat them as genesis vertices
-                    if self.candidate_dag.vertex_count(v.round() - 1) == 0 {
-                        self.candidate_dag.add(v);
-                    }
-                    // Dont add to buffer, `candidate_dag` is our buffer for catchup
-                    return actions;
-                }
-                self.buffer.insert(v.into());
+                self.buffer.add(v);
                 self.metrics.vertex_buffer.set(self.buffer.len());
             }
             Ok(a) => {
@@ -253,14 +231,19 @@ impl Consensus {
                 if v.round() >= self.round() && self.dag.vertex_count(v.round()) >= quorum {
                     actions.extend(self.advance_from_round(v.round()));
                 }
-                for v in std::mem::take(&mut self.buffer) {
-                    if let Ok(a) = self.try_to_add_to_dag(&v) {
+                for (r, v) in self
+                    .buffer
+                    .take_all()
+                    .iter()
+                    .flat_map(|(round, inner_map)| inner_map.values().map(|v| (*round, v)))
+                {
+                    if let Ok(a) = self.try_to_add_to_dag(v) {
                         actions.extend(a);
-                        if v.round() >= self.round() && self.dag.vertex_count(v.round()) >= quorum {
-                            actions.extend(self.advance_from_round(v.round()));
+                        if v.round() >= self.round() && self.dag.vertex_count(r) >= quorum {
+                            actions.extend(self.advance_from_round(r));
                         }
                     } else {
-                        self.buffer.insert(v);
+                        self.buffer.add(v.clone());
                     }
                 }
                 self.metrics.vertex_buffer.set(self.buffer.len());
@@ -599,49 +582,61 @@ impl Consensus {
         source = %Label::new(v.source()))
     )]
     fn try_to_add_to_dag(&mut self, v: &Vertex) -> Result<Vec<Action>, ()> {
-        let dag = if self.catchup {
-            &self.candidate_dag
-        } else {
-            &self.dag
-        };
-        if !v.edges().all(|w| dag.vertex(v.round() - 1, w).is_some()) {
-            debug!(
+        let r = v.round();
+        let prev = v.round() - 1;
+        if !v.edges().all(|w| self.dag.vertex(prev, w).is_some()) {
+            if r >= self.round && r - self.round <= 2.into() {
+                debug!(
+                    node    = %self.label,
+                    round   = %self.round,
+                    vround  = %r,
+                    "not all edges are resolved in dag"
+                );
+                return Err(());
+            }
+
+            if !v.edges().all(|w| self.buffer.vertex(prev, w).is_some()) {
+                debug!(
+                    node    = %self.label,
+                    round   = %self.round,
+                    vround  = %r,
+                    "two or more rounds behind, not all edges are resolved in buffer, catchup failed"
+                );
+                return Err(());
+            }
+            for w in self.buffer.vertices(prev) {
+                self.dag.add(w.clone())
+            }
+            tracing::error!(
                 node    = %self.label,
-                round   = %self.round(),
-                vround  = %v.round(),
-                "not all edges are resolved in dag"
+                round   = %self.round,
+                vround  = %r,
+                "catchup succeeded"
             );
-            return Err(());
-        }
-        // We are able to add again to the `dag`, so catchup is complete
-        // Copy from `candidate_dag` into `dag` then clear
-        if self.catchup {
-            self.catchup = false;
-            self.dag = self.candidate_dag.clone();
-            self.candidate_dag.clear();
+            self.buffer.remove(prev + 1);
         }
 
         self.dag.add(v.clone());
         self.metrics.dag_depth.set(self.dag.depth());
 
-        if v.round() <= self.committed_round {
+        if r <= self.committed_round {
             debug!(
                 node      = %self.label,
                 round     = %self.round(),
                 committed = %self.committed_round,
-                vround    = %v.round(),
+                vround    = %r,
                 "leader has already been committed"
             );
             return Ok(Vec::new());
         }
 
-        if self.dag.vertex_count(v.round()) as u64 >= self.committee.quorum_size().get() {
+        if self.dag.vertex_count(r) as u64 >= self.committee.quorum_size().get() {
             // We have enough vertices => try to commit the leader vertex:
-            let Some(l) = self.leader_vertex(v.round() - 1).cloned() else {
+            let Some(l) = self.leader_vertex(r - 1).cloned() else {
                 debug!(
                     node   = %self.label,
                     round  = %self.round,
-                    vround = %v.round(),
+                    vround = %r,
                     "no leader vertex in vround - 1 => can not commit"
                 );
                 return Ok(Vec::new());
@@ -650,7 +645,7 @@ impl Consensus {
             // leader vertex.
             if self
                 .dag
-                .vertices(v.round())
+                .vertices(r)
                 .filter(|v| v.has_edge(l.source()))
                 .count() as u64
                 >= self.committee.quorum_size().get()
@@ -744,7 +739,7 @@ impl Consensus {
         let r = committed - 2;
         self.dag.remove(r);
         self.delivered.retain(|(x, _)| *x >= r);
-        self.buffer.retain(|v| v.round() >= r);
+        self.buffer.remove(r);
 
         self.metrics.dag_depth.set(self.dag.depth());
         self.metrics.vertex_buffer.set(self.buffer.len());
@@ -885,8 +880,8 @@ impl Consensus {
         &self.dag
     }
 
-    pub fn buffer(&self) -> impl Iterator<Item = &Vertex> {
-        self.buffer.iter().map(|ordered| &ordered.0)
+    pub fn buffer(&self) -> &Dag {
+        &self.buffer
     }
 
     pub fn delivered(&self) -> &HashSet<(RoundNumber, PublicKey)> {
diff --git a/sailfish/src/consensus/dag.rs b/sailfish/src/consensus/dag.rs
index 9edff45..9db3333 100644
--- a/sailfish/src/consensus/dag.rs
+++ b/sailfish/src/consensus/dag.rs
@@ -47,6 +47,17 @@ impl Dag {
         self.elements.keys().copied()
     }
 
+    pub fn take_all(&mut self) -> BTreeMap<RoundNumber, BTreeMap<PublicKey, Vertex>> {
+        std::mem::take(&mut self.elements)
+    }
+
+    pub fn len(&self) -> usize {
+        self.elements
+            .iter()
+            .map(|(_, inner_map)| inner_map.len())
+            .sum()
+    }
+
     /// Returns the highest round number present in the DAG, if any
     pub fn max_round(&self) -> Option<RoundNumber> {
         self.elements.keys().max().cloned()
diff --git a/tests/src/tests/consensus/test_consensus_fake_network.rs b/tests/src/tests/consensus/test_consensus_fake_network.rs
index 2eebc8b..895becd 100644
--- a/tests/src/tests/consensus/test_consensus_fake_network.rs
+++ b/tests/src/tests/consensus/test_consensus_fake_network.rs
@@ -330,7 +330,7 @@ fn basic_liveness() {
                 assert!(n.dag().max_round().unwrap() >= n.committed_round() - 2);
             }
             // No one is late => buffer should always be empty:
-            assert_eq!(0, n.buffer().count());
+            assert_eq!(0, n.buffer().len());
         }
         actions = next
     }
